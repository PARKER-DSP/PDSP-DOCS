---
title: ChordId v1 Canonical Standard
audience: [core, dev, docs, ux]
status: draft
last_reviewed: 2026-02-20
sidebar_position: 30
description: "Canonical ChordId identity standard (separate from voicing)."
tags: [contracts, harmony, chords]
---

# ChordId v1 Canonical Standard

This document standardizes a stable identity for “what chord is this?” so that:

- chord analysis, voicing, and suggestion systems agree on the same chord
- presets/share-links remain stable across versions
- UI labeling is decoupled from core identity (spelling policies)

ChordId is **not** a voicing. ChordId describes the harmonic object; voicing describes realized MIDI notes.

---

## 1) Canonical representation

A `ChordId` is a structured object:

- `root`: pitch class `0..11` (C..B)
- `quality`: one of a canonical enum (below)
- `tones`: a canonical set of chord-tone intervals (in semitones) relative to root
- optional `bass`: pitch class `0..11` for slash chords (display/analysis)

### Why tones are intervals
- They are unambiguous and deterministic.
- They avoid enharmonic spelling problems in core.

---

## 2) Canonical enums

### Pitch class canonical mapping

`0:C, 1:C#, 2:D, 3:D#, 4:E, 5:F, 6:F#, 7:G, 8:G#, 9:A, 10:A#, 11:B`

(Enharmonic display is a policy, not identity.)

### Quality enum (v1)

- `maj`
- `min`
- `dim`
- `aug`
- `sus2`
- `sus4`
- `power` (5)

This is intentionally small. Extensions/alterations are expressed by `tones`.

---

## 3) Tones normalization (normative)

The `tones` array MUST be:

- unique
- sorted ascending
- stored modulo 12 in `[0..11]`
- MUST include `0` (the root)

> Identity scope (v1): because tones are stored **modulo 12**, ChordId v1 represents a **pitch-class set**. It cannot distinguish `add2` vs `add9`, or `6` vs `13`. If you need degree-aware identity, introduce ChordId v2.

### Quality compatibility (normative)

`quality` is not just display text. In v1, it MUST be compatible with `tones`:

- `maj`: tones MUST include 0, 4, 7
- `min`: tones MUST include 0, 3, 7
- `dim`: tones MUST include 0, 3, 6
- `aug`: tones MUST include 0, 4, 8
- `sus2`: tones MUST include 0, 2, 7
- `sus4`: tones MUST include 0, 5, 7
- `power`: tones MUST include 0, 7

Additional tones are allowed (extensions/alterations).

Example (Cmaj7):
- root = 0 (C)
- tones = [0, 4, 7, 11]

Example (C7#11):
- tones = [0, 4, 7, 10, 6] → normalize/sort → [0, 4, 6, 7, 10]

---

## 4) TypeScript types

```ts
export type PitchClass = number; // runtime-validated 0..11

export type ChordQuality =
  | "maj"
  | "min"
  | "dim"
  | "aug"
  | "sus2"
  | "sus4"
  | "power";

export type ChordId = {
  version: 1;
  root: PitchClass;
  quality: ChordQuality;
  tones: number[];   // normalized sorted unique, includes 0
  bass?: PitchClass; // optional slash-bass
};
```

---

## 5) Normalization helper (TS)

```ts
export function normalizeChordId(ch: ChordId): ChordId {
  if (ch.version !== 1) throw new Error("ChordId version mismatch");

  const root = ((ch.root % 12) + 12) % 12;

  const tonesSet = new Set<number>();
  for (const t of ch.tones) {
    const m = ((t % 12) + 12) % 12;
    tonesSet.add(m);
  }
  tonesSet.add(0); // root must be present

  const tones = Array.from(tonesSet).sort((a, b) => a - b);

  const REQUIRED_BY_QUALITY: Record<ChordQuality, readonly number[]> = {
    maj: [0, 4, 7],
    min: [0, 3, 7],
    dim: [0, 3, 6],
    aug: [0, 4, 8],
    sus2: [0, 2, 7],
    sus4: [0, 5, 7],
    power: [0, 7],
  };

  for (const req of REQUIRED_BY_QUALITY[ch.quality]) {
    if (!tonesSet.has(req)) {
      throw new Error(`ChordId quality "${ch.quality}" is incompatible with tones (missing ${req})`);
    }
  }

  const out: ChordId = {
    version: 1,
    root,
    quality: ch.quality,
    tones,
  };

  if (ch.bass !== undefined) out.bass = ((ch.bass % 12) + 12) % 12;

  return out;
}
```

---

## 6) Schema (portable)

```json
{
  "$id": "parker://schema/chordId/v1",
  "type": "object",
  "additionalProperties": false,
  "required": ["version", "root", "quality", "tones"],
  "properties": {
    "version": { "type": "integer", "const": 1 },
    "root": { "type": "integer", "minimum": 0, "maximum": 11 },
    "quality": {
      "type": "string",
      "enum": ["maj", "min", "dim", "aug", "sus2", "sus4", "power"]
    },
    "tones": {
      "type": "array",
      "items": { "type": "integer", "minimum": 0, "maximum": 11 },
      "minItems": 1,
      "uniqueItems": true
    },
    "bass": { "type": "integer", "minimum": 0, "maximum": 11 }
  }
}
```

---

## 7) Display policy (non-canonical)

How you render a `ChordId` as text (e.g., `Dbmaj7` vs `C#maj7`) is UI policy.

Standardize display policies separately:
- accidental style (sharp/flat)
- preferred spellings per key signature / scale context
- jazz symbols vs classical (Δ7 vs maj7)

These must not change identity or serialization.

---

## 8) Test vectors

- C major triad:
  - root: 0
  - quality: "maj"
  - tones: [0, 4, 7]

- Cmaj7:
  - tones: [0, 4, 7, 11]

- C7#11:
  - tones: [0, 4, 6, 7, 10]

If any layer serializes these with unsorted tones, missing root (0), or enharmonic-dependent identity, it is not following ChordId v1.
